#!/bin/bash

# Couleurs pour l'affichage
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Fonction pour afficher l'ASCII art
show_ascii_art() {
    printf "%bâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—%b\n" "$BLUE" "$NC"
    printf "%bâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•%b\n" "$BLUE" "$NC"
    printf "%bâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• %b\n" "$BLUE" "$NC"
    printf "%bâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— %b\n" "$BLUE" "$NC"
    printf "%bâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—%b\n" "$BLUE" "$NC"
    printf "%bâ•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•    â•šâ•â•â•â•šâ•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•%b\n" "$BLUE" "$NC"
    printf "%b â”Œâ”€â”â”Œâ”€â”â”Œâ”€â”â”Œâ”â”Œ   â”¬â”€â”â”Œâ”€â”â”Œâ”€â”â”Œâ”€â”â”Œâ”€â”â”¬ â”¬%b\n" "$CYAN" "$NC"
    printf "%b â””â”€â”â”‚  â”œâ”€â”¤â”‚â”‚â”‚   â”œâ”¬â”˜â”œâ”¤ â””â”€â”â”œâ”¤ â”œâ”€â”¤â”‚ â”‚%b\n" "$CYAN" "$NC"
    printf "%b â””â”€â”˜â””â”€â”˜â”´ â”´â”˜â””â”˜   â”´â””â”€â””â”€â”˜â””â”€â”˜â””â”€â”˜â”´ â”´â””â”€â”˜%b\n" "$CYAN" "$NC"
    printf "%b=======================================================================%b\n" "$PURPLE" "$NC"
    printf "%b               DÃ©tection d'Ã©quipements sur le rÃ©seau                  %b\n" "$GREEN" "$NC"
    printf "%b                           par DeusH4ss                               %b\n" "$BLUE" "$NC"
    printf "%b=======================================================================%b\n" "$PURPLE" "$NC"
}

# Afficher l'ASCII art au dÃ©but
show_ascii_art

# Fonction pour convertir un masque en notation CIDR (ex: 255.255.255.0 â†’ /24)
mask_to_prefix() {
    local mask=$1
    local IFS=.
    local -a octets=($mask)
    local binary=""
    for octet in "${octets[@]}"; do
        binary+=$(printf "%08d" "$(bc <<< "obase=2; $octet")")
    done
    echo "${binary//0/}" | wc -c
}

# Fonction pour calculer l'adresse rÃ©seau
ipcalc() {
    IFS=. read -r i1 i2 i3 i4 <<< "$1"
    IFS=. read -r m1 m2 m3 m4 <<< "$2"
    echo "$((i1 & m1)).$((i2 & m2)).$((i3 & m3)).$((i4 & m4))"
}

# Fonction pour rÃ©soudre les noms d'hÃ´tes
resolve_hostname() {
    local ip=$1
    local hostname=""
    
    # Utiliser nslookup pour trouver le nom d'hÃ´te, en filtrant les rÃ©ponses d'erreur
    hostname=$(nslookup "$ip" 2>/dev/null | grep -i "name =" | awk '{print $4}' | sed 's/\.$//')
    
    # Si nslookup ne retourne pas de rÃ©sultat valide ou retourne une erreur
    if [[ -z "$hostname" || "$hostname" == *"NXDOMAIN"* ]]; then
        # Essayer avec la commande host si disponible
        if command -v host >/dev/null 2>&1; then
            hostname=$(host "$ip" 2>/dev/null | grep -v "not found" | grep "domain name" | awk '{print $5}' | sed 's/\.$//')
        fi
        
        # Essayer avec la commande dig si disponible
        if [[ -z "$hostname" ]] && command -v dig >/dev/null 2>&1; then
            hostname=$(dig +short -x "$ip" 2>/dev/null)
            hostname=${hostname%.}  # Retirer le point final s'il existe
        fi
    fi
    
    # Si un nom d'hÃ´te valide est trouvÃ©, le retourner, sinon retourner "Non rÃ©solu"
    if [[ -n "$hostname" && "$hostname" != *"NXDOMAIN"* && "$hostname" != *"not found"* ]]; then
        echo "$hostname"
    else
        echo "Non rÃ©solu"
    fi
}

# Demande Ã  l'utilisateur s'il veut un scan automatique ou manuel
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo " ğŸ” Scan du rÃ©seau "
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "1ï¸âƒ£  Scan automatique (dÃ©tection de l'IP et du masque)"
echo "2ï¸âƒ£  Scan manuel (saisie de l'IP et du masque)"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
read -p "â¡ï¸  Choisissez une option (1 ou 2) : " choice

# Scan automatique
if [ "$choice" == "1" ]; then
    echo "ğŸ› ï¸  DÃ©tection automatique du rÃ©seau..."
    
    # RÃ©cupÃ©rer l'interface principale
    interface=$(route get default 2>/dev/null | grep 'interface:' | awk '{print $2}')
    if [ -z "$interface" ]; then
        echo "âŒ Impossible de dÃ©tecter l'interface rÃ©seau."
        exit 1
    fi

    # RÃ©cupÃ©rer l'adresse IP de l'interface
    input_ip=$(ipconfig getifaddr "$interface" 2>/dev/null)
    if [ -z "$input_ip" ]; then
        echo "âŒ Impossible de dÃ©tecter l'adresse IP."
        exit 1
    fi

    # RÃ©cupÃ©rer le masque de sous-rÃ©seau
    input_mask=$(ifconfig "$interface" | grep -w "netmask" | awk '{print $4}')
    if [ -z "$input_mask" ]; then
        echo "âŒ Impossible de dÃ©tecter le masque de sous-rÃ©seau."
        exit 1
    fi

    # Convertir le masque hexadÃ©cimal en format standard
    input_mask=$(printf "%d.%d.%d.%d\n" \
        $(( (0x${input_mask:2:2}) )) \
        $(( (0x${input_mask:4:2}) )) \
        $(( (0x${input_mask:6:2}) )) \
        $(( (0x${input_mask:8:2}) )))

# Scan manuel
elif [ "$choice" == "2" ]; then
    echo "ğŸ“ Mode manuel sÃ©lectionnÃ©."
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ“Œ Exemple :"
    echo "  - IP de base : 192.168.42.0"
    echo "  - Masque : 255.255.255.0"
    echo "  - Autre exemple : 169.254.136.208 255.255.0.0"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # DÃ©tecter l'interface principale pour les valeurs par dÃ©faut
    default_interface=$(route get default 2>/dev/null | grep 'interface:' | awk '{print $2}')
    default_ip=""
    default_mask=""
    
    # Si une interface est dÃ©tectÃ©e, essayer d'obtenir l'IP et le masque
    if [ -n "$default_interface" ]; then
        default_ip=$(ipconfig getifaddr "$default_interface" 2>/dev/null)
        
        # Obtenir le masque et le convertir au format standard
        temp_mask=$(ifconfig "$default_interface" 2>/dev/null | grep -w "netmask" | awk '{print $4}')
        if [[ "$temp_mask" == 0x* ]]; then
            default_mask=$(printf "%d.%d.%d.%d\n" \
                $(( (0x${temp_mask:2:2}) )) \
                $(( (0x${temp_mask:4:2}) )) \
                $(( (0x${temp_mask:6:2}) )) \
                $(( (0x${temp_mask:8:2}) )))
        fi
        
        # Calculer l'adresse rÃ©seau pour la valeur par dÃ©faut
        if [ -n "$default_ip" ] && [ -n "$default_mask" ]; then
            # Extraire les octets
            IFS=. read -r i1 i2 i3 i4 <<< "$default_ip"
            IFS=. read -r m1 m2 m3 m4 <<< "$default_mask"
            # Calculer l'adresse rÃ©seau
            default_ip="$((i1 & m1)).$((i2 & m2)).$((i3 & m3)).0"
        else
            # Valeurs par dÃ©faut si la dÃ©tection Ã©choue
            default_ip="192.168.1.0"
            default_mask="255.255.255.0"
        fi
    else
        # Valeurs par dÃ©faut si aucune interface n'est dÃ©tectÃ©e
        default_ip="192.168.1.0"
        default_mask="255.255.255.0"
    fi
    
    # Demander l'adresse IP avec valeur par dÃ©faut
    read -p "â¡ï¸  Entrez l'IP de base [$default_ip] : " input_ip
    input_ip=${input_ip:-$default_ip}  # Utiliser la valeur par dÃ©faut si vide
    
    # Demander le masque avec valeur par dÃ©faut
    read -p "â¡ï¸  Entrez le masque de sous-rÃ©seau [$default_mask] : " input_mask
    input_mask=${input_mask:-$default_mask}  # Utiliser la valeur par dÃ©faut si vide
else
    # Boucle jusqu'Ã  ce que l'utilisateur entre une option valide
    while [[ "$choice" != "1" && "$choice" != "2" ]]; do
        echo -e "${RED}âŒ Option invalide. Veuillez choisir 1 ou 2.${NC}"
        read -p "â¡ï¸  Choisissez une option (1 ou 2) : " choice
    done
    
    # Retour au dÃ©but du script pour traiter l'option valide
    if [ "$choice" == "1" ]; then
        echo "ğŸ› ï¸  DÃ©tection automatique du rÃ©seau..."
        # RÃ©cupÃ©rer l'interface principale
        interface=$(route get default 2>/dev/null | grep 'interface:' | awk '{print $2}')
        if [ -z "$interface" ]; then
            echo "âŒ Impossible de dÃ©tecter l'interface rÃ©seau."
            exit 1
        fi

        # RÃ©cupÃ©rer l'adresse IP de l'interface
        input_ip=$(ipconfig getifaddr "$interface" 2>/dev/null)
        if [ -z "$input_ip" ]; then
            echo "âŒ Impossible de dÃ©tecter l'adresse IP."
            exit 1
        fi

        # RÃ©cupÃ©rer le masque de sous-rÃ©seau
        input_mask=$(ifconfig "$interface" | grep -w "netmask" | awk '{print $4}')
        if [ -z "$input_mask" ]; then
            echo "âŒ Impossible de dÃ©tecter le masque de sous-rÃ©seau."
            exit 1
        fi

        # Convertir le masque hexadÃ©cimal en format standard
        input_mask=$(printf "%d.%d.%d.%d\n" \
            $(( (0x${input_mask:2:2}) )) \
            $(( (0x${input_mask:4:2}) )) \
            $(( (0x${input_mask:6:2}) )) \
            $(( (0x${input_mask:8:2}) )))
    elif [ "$choice" == "2" ]; then
        echo "ğŸ“ Mode manuel sÃ©lectionnÃ©."
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“Œ Exemple :"
        echo "  - IP de base : 192.168.42.0"
        echo "  - Masque : 255.255.255.0"
        echo "  - Autre exemple : 169.254.136.208 255.255.0.0"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

        # DÃ©tecter l'interface principale pour les valeurs par dÃ©faut
        default_interface=$(route get default 2>/dev/null | grep 'interface:' | awk '{print $2}')
        default_ip=""
        default_mask=""
        
        # Si une interface est dÃ©tectÃ©e, essayer d'obtenir l'IP et le masque
        if [ -n "$default_interface" ]; then
            default_ip=$(ipconfig getifaddr "$default_interface" 2>/dev/null)
            
            # Obtenir le masque et le convertir au format standard
            temp_mask=$(ifconfig "$default_interface" 2>/dev/null | grep -w "netmask" | awk '{print $4}')
            if [[ "$temp_mask" == 0x* ]]; then
                default_mask=$(printf "%d.%d.%d.%d\n" \
                    $(( (0x${temp_mask:2:2}) )) \
                    $(( (0x${temp_mask:4:2}) )) \
                    $(( (0x${temp_mask:6:2}) )) \
                    $(( (0x${temp_mask:8:2}) )))
            fi
            
            # Calculer l'adresse rÃ©seau pour la valeur par dÃ©faut
            if [ -n "$default_ip" ] && [ -n "$default_mask" ]; then
                # Extraire les octets
                IFS=. read -r i1 i2 i3 i4 <<< "$default_ip"
                IFS=. read -r m1 m2 m3 m4 <<< "$default_mask"
                # Calculer l'adresse rÃ©seau
                default_ip="$((i1 & m1)).$((i2 & m2)).$((i3 & m3)).0"
            else
                # Valeurs par dÃ©faut si la dÃ©tection Ã©choue
                default_ip="192.168.1.0"
                default_mask="255.255.255.0"
            fi
        else
            # Valeurs par dÃ©faut si aucune interface n'est dÃ©tectÃ©e
            default_ip="192.168.1.0"
            default_mask="255.255.255.0"
        fi
        
        # Demander l'adresse IP avec valeur par dÃ©faut
        read -p "â¡ï¸  Entrez l'IP de base [$default_ip] : " input_ip
        input_ip=${input_ip:-$default_ip}  # Utiliser la valeur par dÃ©faut si vide
        
        # Demander le masque avec valeur par dÃ©faut
        read -p "â¡ï¸  Entrez le masque de sous-rÃ©seau [$default_mask] : " input_mask
        input_mask=${input_mask:-$default_mask}  # Utiliser la valeur par dÃ©faut si vide
    fi
fi

# VÃ©rifie que les entrÃ©es sont valides (IPV4 et masque corrects)
ip_valid=false
mask_valid=false

while [ "$ip_valid" = false ] || [ "$mask_valid" = false ]; do
    # VÃ©rification de l'IP
    if [ "$ip_valid" = false ]; then
        if [[ "$input_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            ip_valid=true
        else
            echo -e "${RED}âŒ Format IP invalide. Exemple : 192.168.1.0${NC}"
            read -p "â¡ï¸  Veuillez entrer Ã  nouveau l'IP de base : " input_ip
        fi
    fi
    
    # VÃ©rification du masque
    if [ "$mask_valid" = false ]; then
        if [[ "$input_mask" =~ ^(255\.(255|254|252|248|240|224|192|128|0)\.0\.0|255\.255\.(255|254|252|248|240|224|192|128|0)\.0|255\.255\.255\.(255|254|252|248|240|224|192|128|0))$ ]]; then
            mask_valid=true
        else
            echo -e "${RED}âŒ Format de masque invalide. Exemple : 255.255.255.0${NC}"
            read -p "â¡ï¸  Veuillez entrer Ã  nouveau le masque de sous-rÃ©seau : " input_mask
        fi
    fi
done

# Convertir le masque en prÃ©fixe (ex: 255.255.255.0 â†’ /24)
prefix=$(mask_to_prefix "$input_mask")

# Calcul de l'adresse rÃ©seau
network_ip=$(ipcalc "$input_ip" "$input_mask")

# DÃ©termine la plage d'adresses
IFS=. read -r n1 n2 n3 n4 <<< "$network_ip"
IFS=. read -r m1 m2 m3 m4 <<< "$input_mask"
host_min=$(( (256 + n4 + 1) % 256 ))  # PremiÃ¨re IP utilisable
host_max=$(( (n4 | (255 - m4)) - 1 )) # DerniÃ¨re IP utilisable

# Option pour afficher les noms d'hÃ´tes
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ğŸ” Options de scan"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "1ï¸âƒ£  Scan rapide (ping uniquement)"
echo "2ï¸âƒ£  Scan dÃ©taillÃ© (ping + rÃ©solution de noms)"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
read -p "â¡ï¸  Choisissez une option (1 ou 2) : " scan_option

# En-tÃªte rÃ©sultats
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "${BLUE}ğŸ“¡ Scan en cours sur $network_ip/$prefix...${NC}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# CrÃ©er un fichier temporaire pour stocker les rÃ©sultats
temp_file=$(mktemp)

# Scan du rÃ©seau
for i in $(seq "$host_min" "$host_max"); do
    ip="$n1.$n2.$n3.$i"
    {
        if ping -c 1 -t 1 "$ip" &>/dev/null; then
            if [ "$scan_option" == "2" ]; then
                hostname=$(resolve_hostname "$ip")
                echo "$ip $hostname" >> "$temp_file"
            else
                echo "$ip" >> "$temp_file"
            fi
        fi
    } &
    
    # Limiter le nombre de processus en parallÃ¨le
    if [[ $(jobs -r | wc -l) -ge 20 ]]; then
        wait # Attendre que tous les jobs se terminent
    fi
done

wait

# Afficher les rÃ©sultats triÃ©s
if [ "$scan_option" == "2" ]; then
    echo -e "${YELLOW}Adresse IP        Nom d'hÃ´te${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    sort -V "$temp_file" | while read -r line; do
        ip=$(echo "$line" | awk '{print $1}')
        hostname=$(echo "$line" | cut -d ' ' -f 2-)
        
        # VÃ©rifier si l'hostname contient "NXDOMAIN" ou autres erreurs
        if [[ "$hostname" == *"NXDOMAIN"* || "$hostname" == *"not found"* ]]; then
            hostname="Non rÃ©solu"
        fi
        
        if [ "$hostname" != "Non rÃ©solu" ]; then
            echo -e "${GREEN}âœ… $ip\t${CYAN}$hostname${NC}"
        else
            echo -e "${GREEN}âœ… $ip\t${YELLOW}$hostname${NC}"
        fi
    done
else
    echo -e "${YELLOW}Adresses IP actives${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    sort -V "$temp_file" | while read -r ip; do
        echo -e "${GREEN}âœ… $ip${NC}"
    done
fi

# Supprimer le fichier temporaire
rm -f "$temp_file"

echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "${GREEN}âœ… Scan terminÃ©.${NC}"
